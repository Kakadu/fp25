<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast (Svirukov.Lambda_lib.Ast)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">Svirukov</a> &#x00BB; <a href="../index.html">Lambda_lib</a> &#x00BB; Ast</nav><header class="odoc-preamble"><h1>Module <code><span>Lambda_lib.Ast</span></code></h1><p>Copyright 2021-2025, Kakadu and contributors</p></header><div class="odoc-content"><p>SPDX-License-Identifier: LGPL-3.0-or-later</p><div class="odoc-spec"><div class="spec type anchored" id="type-constant"><a href="#type-constant" class="anchor"></a><code><span><span class="keyword">type</span> constant</span><span> = </span></code><ol><li id="type-constant.CInt" class="def variant constructor anchored"><a href="#type-constant.CInt" class="anchor"></a><code><span>| </span><span><span class="constructor">CInt</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer literals *</p><span class="comment-delim">*)</span></div></li><li id="type-constant.CUnit" class="def variant constructor anchored"><a href="#type-constant.CUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">CUnit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unit value - returned by statements *</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Constant values in the language *</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span><span class="keyword">type</span> pattern</span><span> = </span></code><ol><li id="type-pattern.PVar" class="def variant constructor anchored"><a href="#type-pattern.PVar" class="anchor"></a><code><span>| </span><span><span class="constructor">PVar</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variable pattern - binds to a name *</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Patterns for variable binding *</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-rec_flag"><a href="#type-rec_flag" class="anchor"></a><code><span><span class="keyword">type</span> rec_flag</span><span> = </span></code><ol><li id="type-rec_flag.NonRec" class="def variant constructor anchored"><a href="#type-rec_flag.NonRec" class="anchor"></a><code><span>| </span><span><span class="constructor">NonRec</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Non-recursive binding **</p><span class="comment-delim">*)</span></div></li><li id="type-rec_flag.Rec" class="def variant constructor anchored"><a href="#type-rec_flag.Rec" class="anchor"></a><code><span>| </span><span><span class="constructor">Rec</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Recursive binding **</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Recursion flag for let bindings *</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binop"><a href="#type-binop" class="anchor"></a><code><span><span class="keyword">type</span> binop</span><span> = </span></code><ol><li id="type-binop.Plus" class="def variant constructor anchored"><a href="#type-binop.Plus" class="anchor"></a><code><span>| </span><span><span class="constructor">Plus</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer addition: + *</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Minus" class="def variant constructor anchored"><a href="#type-binop.Minus" class="anchor"></a><code><span>| </span><span><span class="constructor">Minus</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer subtraction: - *</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Asteriks" class="def variant constructor anchored"><a href="#type-binop.Asteriks" class="anchor"></a><code><span>| </span><span><span class="constructor">Asteriks</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer multiplication: * *</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Dash" class="def variant constructor anchored"><a href="#type-binop.Dash" class="anchor"></a><code><span>| </span><span><span class="constructor">Dash</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer division: / *</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Equals" class="def variant constructor anchored"><a href="#type-binop.Equals" class="anchor"></a><code><span>| </span><span><span class="constructor">Equals</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer equality: = *</p><span class="comment-delim">*)</span></div></li><li id="type-binop.MoreThan" class="def variant constructor anchored"><a href="#type-binop.MoreThan" class="anchor"></a><code><span>| </span><span><span class="constructor">MoreThan</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer greater than: &gt; *</p><span class="comment-delim">*)</span></div></li><li id="type-binop.LessThan" class="def variant constructor anchored"><a href="#type-binop.LessThan" class="anchor"></a><code><span>| </span><span><span class="constructor">LessThan</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer less than: &lt; *</p><span class="comment-delim">*)</span></div></li><li id="type-binop.EqLess" class="def variant constructor anchored"><a href="#type-binop.EqLess" class="anchor"></a><code><span>| </span><span><span class="constructor">EqLess</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer less than or equal: &lt;= *</p><span class="comment-delim">*)</span></div></li><li id="type-binop.EqMore" class="def variant constructor anchored"><a href="#type-binop.EqMore" class="anchor"></a><code><span>| </span><span><span class="constructor">EqMore</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer greater than or equal: &gt;= *</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Binary operators *</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = </span></code><ol><li id="type-expr.Constant" class="def variant constructor anchored"><a href="#type-expr.Constant" class="anchor"></a><code><span>| </span><span><span class="constructor">Constant</span> <span class="keyword">of</span> <a href="#type-constant">constant</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Constant values - integers and unit *</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Var" class="def variant constructor anchored"><a href="#type-expr.Var" class="anchor"></a><code><span>| </span><span><span class="constructor">Var</span> <span class="keyword">of</span> <a href="#type-pattern">pattern</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variable reference - looks up a bound name *</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Let" class="def variant constructor anchored"><a href="#type-expr.Let" class="anchor"></a><code><span>| </span><span><span class="constructor">Let</span> <span class="keyword">of</span> <a href="#type-rec_flag">rec_flag</a> * <a href="#type-pattern">pattern</a> * <a href="#type-expr">expr</a> * <span><a href="#type-expr">expr</a> option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Let binding:</p><ul><li>rec_flag: whether binding is recursive</li><li>pattern: variable name to bind</li><li>expr: value to bind</li><li>expr option: optional body expression (if None, it's a statement) *</li></ul><span class="comment-delim">*)</span></div></li><li id="type-expr.Func" class="def variant constructor anchored"><a href="#type-expr.Func" class="anchor"></a><code><span>| </span><span><span class="constructor">Func</span> <span class="keyword">of</span> <a href="#type-pattern">pattern</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Lambda abstraction:</p><ul><li>pattern: parameter name</li><li>expr: function body *</li></ul><span class="comment-delim">*)</span></div></li><li id="type-expr.App" class="def variant constructor anchored"><a href="#type-expr.App" class="anchor"></a><code><span>| </span><span><span class="constructor">App</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function application:</p><ul><li>expr: function expression</li><li>expr: argument expression *</li></ul><span class="comment-delim">*)</span></div></li><li id="type-expr.Binop" class="def variant constructor anchored"><a href="#type-expr.Binop" class="anchor"></a><code><span>| </span><span><span class="constructor">Binop</span> <span class="keyword">of</span> <a href="#type-binop">binop</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Binary operation:</p><ul><li>binop: operator</li><li>expr: left operand</li><li>expr: right operand *</li></ul><span class="comment-delim">*)</span></div></li><li id="type-expr.Conditional" class="def variant constructor anchored"><a href="#type-expr.Conditional" class="anchor"></a><code><span>| </span><span><span class="constructor">Conditional</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <span><a href="#type-expr">expr</a> option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Conditional expression:</p><ul><li>expr: condition (must evaluate to int, 0=false, non-zero=true)</li><li>expr: then branch</li><li>expr option: optional else branch *</li></ul><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Expressions in miniML language *</p></div></div><p>Notes:</p><ul><li>Evaluation strategy: Call-by-value (CBV)</li><li>All binary operators work only on integers</li><li>Conditionals use integers as booleans (0 = false, non-zero = true)</li><li>Functions are curried: fun x y -&gt; ... desugars to fun x -&gt; fun y -&gt; ...</li><li>Let bindings without 'in' are statements, with 'in' are expressions</li><li>Type system supports integers, functions, and unit *</li></ul></div></body></html>
