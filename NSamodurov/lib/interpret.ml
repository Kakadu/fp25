[@@@ocaml.text "/*"]

(** Copyright 2021-2024, Kakadu and contributors *)

(** SPDX-License-Identifier: LGPL-3.0-or-later *)

[@@@ocaml.text "/*"]

(**
   ZINC abstract machine with cyclic enviroment for recursion

   Literature: https://caml.inria.fr/pub/papers/xleroy-zinc.pdf
*)

open Parser
open Compiler
open Monads
open Utils
open Type

type output = string list
type flags = { print_instr_exec : bool (** If set, print instruction executed *) }

module ErrorMonad : sig
  include GENERAL_MONAD_2

  val fail : 's -> ('s, 'a) t
  val run : ('s, 'a) t -> (int * output) * ('a, 's) Result.t
  val write : string -> ('s, unit) t
  val tick : ('s, unit) t
end = struct
  type ('s, 'a) t = int * output -> (int * output) * ('a, 's) Result.t

  let fail e s = s, Result.error e
  let return x s = s, Result.ok x
  let write x = fun (i, out) -> (i, x :: out), Result.ok ()
  let tick (i, out) = (i + 1, out), Result.ok ()

  let bind =
    fun o f st ->
    let out, r = o st in
    match r with
    | Result.Error _ as e -> out, e
    | Ok v -> (f v) out
  ;;

  let run m = m (0, [])

  module Syntax = struct
    let ( let* ) = bind
    let ( >>= ) = bind
  end
end

open ErrorMonad
open ErrorMonad.Syntax

(** A type of value used in interepreter *)
type eval =
  | Pair of int (** Pairs, used to sotre closure *)
  | Int of int (** Integer *)
  | Epsilon (** Distingueshed symbol used for "frames" *)
  | DummyStack of int (** Symbol generated by Dummy instruction *)
[@@deriving show { with_path = false }]

let int_of_bool = fun x -> if x then Int 1 else Int 0

(** a sequence of instructions that retains state *)
type closure = instr list * eval list

(** A state of interpreter  *)
type state =
  { acc : eval (** Accumulator *)
  ; env : eval list (** Enviroment stack *)
  ; arg : eval list (** Argument stack *)
  ; ret : eval list (** Return value stack *)
  ; curs : closure IMap.t (** Array of closures *)
  }

let print_state { acc; env; arg; ret; _ } instr =
  (match instr with
   | [] -> ()
   | h :: _ -> Format.printf ">>>>>>>>>>>>>>>>  %a <<<<<<<<<<<<< \n" pp_instr h);
  Format.printf "acc: %a\n" pp_eval acc;
  Format.printf "env: ";
  List.iter (Format.printf "%a, " pp_eval) env;
  Format.printf "\n";
  Format.printf "arg: ";
  List.iter (Format.printf "%a, " pp_eval) arg;
  Format.printf "\n";
  Format.printf "ret: ";
  List.iter (Format.printf ">>>>>>>>>>>>>>%a, \n" pp_eval) ret;
  Format.printf "\n"
;;

let interpret =
  let rec helper { acc; env; arg; ret; curs } instr =
    (* print_state { acc; env; arg; ret; curs } instr; *)
    tick
    >>= fun _ ->
    match instr with
    | [] -> return acc
    | Primitive p :: instr ->
      (match p, acc, arg with
       | Add, Int a, Int b :: arg ->
         helper { acc = Int (a + b); env; arg; ret; curs } instr
       | Sub, Int a, Int b :: arg ->
         helper { acc = Int (a - b); env; arg; ret; curs } instr
       | Mul, Int a, Int b :: arg ->
         helper { acc = Int (a * b); env; arg; ret; curs } instr
       | Div, Int a, Int b :: arg ->
         helper { acc = Int (a / b); env; arg; ret; curs } instr
       | Less, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a < b); env; arg; ret; curs } instr
       | Great, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a > b); env; arg; ret; curs } instr
       | LessEq, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a <= b); env; arg; ret; curs } instr
       | GreatEq, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a >= b); env; arg; ret; curs } instr
       | Equal, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a = b); env; arg; ret; curs } instr
       | NeqPhysical, Int a, Int b :: arg | NeqStruct, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a <> b); env; arg; ret; curs } instr
       | And, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a != 0 && b != 0); env; arg; ret; curs } instr
       | Or, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a != 0 || b != 0); env; arg; ret; curs } instr
       | _, _, [] -> fail (`InterpretError "Arg stack is empty in Add")
       | _ -> fail (`InterpretError "Operand is not int"))
    | Const i :: instr -> helper { acc = Int i; env; arg; ret; curs } instr
    (* Accesing local variable *)
    | Access n :: instr ->
      if n < 0
      then fail (`InterpretError "Found negative index")
      else (
        match List.nth_opt env n with
        | Some x -> helper { acc = x; env; arg; ret; curs } instr
        | None -> fail (`InterpretError "Can't access a variable"))
    (* Applications *)
    | AppTerm :: _ ->
      (match acc, arg with
       | Pair ind, v :: arg ->
         let instr, env2 = IMap.find ind curs in
         helper { acc; env = v :: env2; arg; ret; curs } instr
       | DummyStack ind2, v :: arg ->
         let instr2, env2 = IMap.find ind2 curs in
         helper { acc; env = v :: env2; arg; ret; curs } instr2
       | Pair _, _ -> fail (`InterpretError "Argument stack is empty")
       | _ -> fail (`InterpretError "Expected pair in AppTerm"))
    | Apply :: instr ->
      (match acc, arg with
       | Pair ind2, v :: arg ->
         let instr2, env2 = IMap.find ind2 curs in
         let new_ind = IMap.cardinal curs in
         let curs = IMap.add new_ind (instr, env) curs in
         helper { acc; env = v :: env2; arg; ret = Pair new_ind :: ret; curs } instr2
       | DummyStack ind2, v :: arg ->
         let instr2, env2 = IMap.find ind2 curs in
         let new_ind = IMap.cardinal curs in
         let curs = IMap.add new_ind (instr, env) curs in
         helper
           { acc; env = v :: env2; arg; ret = DummyStack new_ind :: ret; curs }
           instr2
       | Pair _, [] -> fail (`InterpretError "Argument stack is empty in Apply")
       | _ -> fail (`InterpretError "Expected pair in Apply"))
    | Push :: instr -> helper { acc; env; arg = acc :: arg; ret; curs } instr
    | PushMark :: instr -> helper { acc; env; arg = Epsilon :: arg; ret; curs } instr
    (* Abstractions *)
    | Cur cur :: instr ->
      let new_ind = IMap.cardinal curs in
      let curs = IMap.add new_ind (cur, env) curs in
      helper { acc = Pair new_ind; env; arg; ret; curs } instr
    | Grab :: instr ->
      (match arg, ret with
       | Epsilon :: arg, Pair ind2 :: ret ->
         let instr2, env2 = IMap.find ind2 curs in
         let new_ind = IMap.cardinal curs in
         let curs = IMap.add new_ind (instr, env) curs in
         helper { acc = Pair new_ind; env = env2; arg; ret; curs } instr2
       | v :: arg, ret -> helper { acc; env = v :: env; arg; ret; curs } instr
       | _, [] -> fail (`InterpretError "Return stack is empty")
       | [], _ :: _ -> fail (`InterpretError "Argument stack is empty"))
    | Return :: _ ->
      (match acc, arg, ret with
       | acc, Epsilon :: arg, Pair ind2 :: ret ->
         let instr2, env2 = IMap.find ind2 curs in
         helper { acc; env = env2; arg; ret; curs } instr2
       | acc, Epsilon :: arg, DummyStack ind2 :: ret ->
         let instr2, env2 = IMap.find ind2 curs in
         helper { acc; env = env2; arg; ret; curs } instr2
       | Pair ind2, v :: arg, ret ->
         let instr2, env2 = IMap.find ind2 curs in
         helper { acc; env = v :: env2; arg; ret; curs } instr2
       | _ -> fail (`InterpretError "Don't know what to do with Return"))
    (* Local declarations *)
    | Let :: instr -> helper { acc; env = acc :: env; arg; ret; curs } instr
    | EndLet :: instr ->
      (match env with
       | [] -> fail (`InterpretError "Enviroment is empty")
       | _ :: tl -> helper { acc; env = tl; arg; ret; curs } instr)
    (* Recursion *)
    | Dummy :: instr -> helper { acc; env = DummyStack (-1) :: env; arg; ret; curs } instr
    | Update :: instr ->
      (match acc, env with
       | Pair ind2, DummyStack _ :: env ->
         let instr2, env2 = IMap.find ind2 curs in
         let rec a = function
           | [] -> []
           | DummyStack _ :: tl -> DummyStack ind2 :: tl
           | h :: tl -> h :: a tl
         in
         let e = a env2 in
         let curs = IMap.add ind2 (instr2, e) curs in
         helper { acc; env = Pair ind2 :: env; arg; ret; curs } instr
       | _ -> fail (`InterpretError "Can't Update"))
    (* Branching *)
    | Branch n :: instr ->
      let instr = List.drop n instr in
      helper { acc; env; arg; ret; curs } instr
    | BranchIf n :: instr ->
      let instr =
        match acc with
        | Int i when i = 0 -> List.drop n instr
        | _ -> instr
      in
      helper { acc; env; arg; ret; curs } instr
    (* Misc. *)
    | Print :: instr ->
      (match acc with
       | Int i ->
         let* () = write (string_of_int i) in
         helper { acc; env; arg; ret; curs } instr
       | _ -> fail (`InterpretError "Can't print what's not int"))
  in
  fun instr ->
    run (helper { acc = Epsilon; env = []; arg = []; ret = []; curs = IMap.empty } instr)
;;

let parse_and_run str { print_instr_exec } =
  let helper str =
    let ( let* ) = Result.bind in
    let* ast = parse str in
    let ast = to_brujin ast in
    let _ = Inferencer.w ast in
    let instr = compile ast in
    let out, r = interpret instr in
    let* r = r in
    Result.ok (out, r)
  in
  match helper str with
  | Ok ((i, out), v) ->
    List.iter (Format.printf "%s\n") (List.rev out);
    if print_instr_exec then Format.printf "Number of intructions executed : %d\n" i;
    Format.printf "Success: %a" pp_eval v
  | Error e -> Format.printf "Error: %a" pp_error e
;;
