[@@@ocaml.text "/*"]

(** Copyright 2021-2024, Kakadu and contributors *)

(** SPDX-License-Identifier: LGPL-3.0-or-later *)

[@@@ocaml.text "/*"]

(**
   ZINC abstract machine with cyclic enviroment for recursion

   Literature: https://caml.inria.fr/pub/papers/xleroy-zinc.pdf
*)

open Parser
open Compiler
open Monads
open Utils

module ErrorMonad : sig
  include GENERAL_MONAD_2

  val fail : 's -> ('s, 'a) t
  val run : ('s, 'a) t -> ('a, 's) Result.t
end = struct
  type ('s, 'a) t = ('a, 's) Result.t

  let fail = Result.error
  let return = Result.ok
  let bind = Result.bind
  let run = Fun.id

  module Syntax = struct
    let ( let* ) = bind
    let ( >>= ) = bind
  end
end

open ErrorMonad

(** A type of value used in interepreter *)
type eval =
  | Pair of int (** Pairs, used to sotre closure *)
  | Int of int (** Integer *)
  | Epsilon (** Distingueshed symbol used for "frames" *)
  | DummyStack of int (** Symbol generated by Dummy instruction *)
[@@deriving show { with_path = false }]

let int_of_bool = fun x -> if x then Int 1 else Int 0

(** a sequence of instructions that retains state *)
type closure = instr list * eval list

(** A state of interpreter  *)
type state =
  { acc : eval (** Accumulator *)
  ; env : eval list (** Enviroment stack *)
  ; arg : eval list (** Argument stack *)
  ; ret : eval list (** Return value stack *)
  ; curs : closure Dynarray.t (** Array of closures *)
  }

let print_state { acc; env; arg; ret; _ } instr =
  (match instr with
   | [] -> ()
   | h :: _ -> Format.printf ">>>>>>>>>>>>>>>>  %a <<<<<<<<<<<<< \n" pp_instr h);
  Format.printf "acc: %a\n" pp_eval acc;
  Format.printf "env: ";
  List.iter (Format.printf "%a, " pp_eval) env;
  Format.printf "\n";
  Format.printf "arg: ";
  List.iter (Format.printf "%a, " pp_eval) arg;
  Format.printf "\n";
  Format.printf "ret: ";
  List.iter (Format.printf ">>>>>>>>>>>>>>%a, \n" pp_eval) ret;
  Format.printf "\n"
;;

(* TODO: remove mutability *)
let interpret =
  let rec helper { acc; env; arg; ret; curs } instr =
    (* print_state { acc; env; arg; ret; curs } instr; *)
    match instr with
    | [] -> return acc
    | Primitive p :: instr ->
      (match p, acc, arg with
       | Add, Int a, Int b :: arg ->
         helper { acc = Int (a + b); env; arg; ret; curs } instr
       | Sub, Int a, Int b :: arg ->
         helper { acc = Int (a - b); env; arg; ret; curs } instr
       | Mul, Int a, Int b :: arg ->
         helper { acc = Int (a * b); env; arg; ret; curs } instr
       | Div, Int a, Int b :: arg ->
         helper { acc = Int (a / b); env; arg; ret; curs } instr
       | Less, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a < b); env; arg; ret; curs } instr
       | Great, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a > b); env; arg; ret; curs } instr
       | LessEq, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a <= b); env; arg; ret; curs } instr
       | GreatEq, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a >= b); env; arg; ret; curs } instr
       | Equal, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a = b); env; arg; ret; curs } instr
       | NeqPhysical, Int a, Int b :: arg | NeqStruct, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a <> b); env; arg; ret; curs } instr
       | And, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a != 0 && b != 0); env; arg; ret; curs } instr
       | Or, Int a, Int b :: arg ->
         helper { acc = int_of_bool (a != 0 || b != 0); env; arg; ret; curs } instr
       | _, _, [] -> fail (`InterpretError "Arg stack is empty in Add")
       | _ -> fail (`InterpretError "Operand is not int"))
    | Const i :: instr -> helper { acc = Int i; env; arg; ret; curs } instr
    (* Accesing local variable *)
    | Access n :: instr ->
      if n < 0
      then fail (`InterpretError "Found negative index")
      else (
        match List.nth_opt env n with
        | Some x -> helper { acc = x; env; arg; ret; curs } instr
        | None -> fail (`InterpretError "Can't access a variable"))
    (* Applications *)
    | AppTerm :: _ ->
      (match acc, arg with
       | Pair ind, v :: arg ->
         let instr, env2 = Dynarray.get curs ind in
         helper { acc; env = v :: env2; arg; ret; curs } instr
       | DummyStack ind2, v :: arg ->
         let instr2, env2 = Dynarray.get curs ind2 in
         helper { acc; env = v :: env2; arg; ret; curs } instr2
       | Pair _, _ -> fail (`InterpretError "Argument stack is empty")
       | _ -> fail (`InterpretError "Expected pair in AppTerm"))
    | Apply :: instr ->
      (match acc, arg with
       | Pair ind2, v :: arg ->
         let instr2, env2 = Dynarray.get curs ind2 in
         let new_ind = Dynarray.length curs in
         Dynarray.add_last curs (instr, env);
         helper { acc; env = v :: env2; arg; ret = Pair new_ind :: ret; curs } instr2
       | DummyStack ind2, v :: arg ->
         let instr2, env2 = Dynarray.get curs ind2 in
         let new_ind = Dynarray.length curs in
         Dynarray.add_last curs (instr, env);
         helper
           { acc; env = v :: env2; arg; ret = DummyStack new_ind :: ret; curs }
           instr2
       | Pair _, [] -> fail (`InterpretError "Argument stack is empty in Apply")
       | _ -> fail (`InterpretError "Expected pair in Apply"))
    | Push :: instr -> helper { acc; env; arg = acc :: arg; ret; curs } instr
    | PushMark :: instr -> helper { acc; env; arg = Epsilon :: arg; ret; curs } instr
    (* Abstractions *)
    | Cur cur :: instr ->
      let new_ind = Dynarray.length curs in
      Dynarray.add_last curs (cur, env);
      helper { acc = Pair new_ind; env; arg; ret; curs } instr
    | Grab :: instr ->
      (match arg, ret with
       | Epsilon :: arg, Pair ind2 :: ret ->
         let instr2, env2 = Dynarray.get curs ind2 in
         let new_ind = Dynarray.length curs in
         Dynarray.add_last curs (instr, env);
         helper { acc = Pair new_ind; env = env2; arg; ret; curs } instr2
       | v :: arg, ret -> helper { acc; env = v :: env; arg; ret; curs } instr
       | _, [] -> fail (`InterpretError "Return stack is empty")
       | [], _ :: _ -> fail (`InterpretError "Argument stack is empty"))
    | Return :: _ ->
      (match acc, arg, ret with
       | acc, Epsilon :: arg, Pair ind2 :: ret ->
         let instr2, env2 = Dynarray.get curs ind2 in
         helper { acc; env = env2; arg; ret; curs } instr2
       | acc, Epsilon :: arg, DummyStack ind2 :: ret ->
         let instr2, env2 = Dynarray.get curs ind2 in
         helper { acc; env = env2; arg; ret; curs } instr2
       | Pair ind2, v :: arg, ret ->
         let instr2, env2 = Dynarray.get curs ind2 in
         helper { acc; env = v :: env2; arg; ret; curs } instr2
       | _ -> fail (`InterpretError "Don't know what to do with Return"))
    (* Local declarations *)
    | Let :: instr -> helper { acc; env = acc :: env; arg; ret; curs } instr
    | EndLet :: instr ->
      (match env with
       | [] -> fail (`InterpretError "Enviroment is empty")
       | _ :: tl -> helper { acc; env = tl; arg; ret; curs } instr)
    (* Recursion *)
    | Dummy :: instr -> helper { acc; env = DummyStack (-1) :: env; arg; ret; curs } instr
    | Update :: instr ->
      (match acc, env with
       | Pair ind2, DummyStack _ :: env ->
         let instr2, env2 = Dynarray.get curs ind2 in
         let rec a = function
           | [] -> []
           | DummyStack _ :: tl -> DummyStack ind2 :: tl
           | h :: tl -> h :: a tl
         in
         let e = a env2 in
         Dynarray.set curs ind2 (instr2, e);
         helper { acc; env = Pair ind2 :: env; arg; ret; curs } instr
       | _ -> fail (`InterpretError "Can't Update"))
    (* Branching *)
    | Branch n :: instr ->
      let instr = List.drop n instr in
      helper { acc; env; arg; ret; curs } instr
    | BranchIf n :: instr ->
      let instr =
        match acc with
        | Int i when i = 0 -> List.drop n instr
        | _ -> instr
      in
      helper { acc; env; arg; ret; curs } instr
  in
  let arr = Stdlib.Dynarray.create () in
  helper { acc = Epsilon; env = []; arg = []; ret = []; curs = arr }
;;

let parse_and_run str =
  let helper str =
    let ( let* ) = Result.bind in
    let* ast = parse str in
    let ast = to_brujin ast in
    let _ = Inferencer.w ast in
    let instr = compile ast in
    run (interpret instr)
  in
  match helper str with
  | Ok v -> Format.printf "Success: %a" pp_eval v
  | Error e -> Format.printf "Error: %a" pp_error e
;;
