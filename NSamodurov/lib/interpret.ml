[@@@ocaml.text "/*"]

(** Copyright 2021-2024, Kakadu and contributors *)

(** SPDX-License-Identifier: LGPL-3.0-or-later *)

[@@@ocaml.text "/*"]

(** https://caml.inria.fr/pub/papers/xleroy-zinc.pdf *)

open Parser
open Compiler
open Monads
open Inferencer
open Utils

module ErrorMonad : sig
  include GENERAL_MONAD_2

  val fail : 's -> ('s, 'a) t
  val run : ('s, 'a) t -> ('a, 's) Result.t
end = struct
  type ('s, 'a) t = ('a, 's) Result.t

  let fail = Result.error
  let return = Result.ok
  let bind = Result.bind
  let run = Fun.id

  module Syntax = struct
    let ( let* ) = bind
    let ( >>= ) = bind
  end
end

open ErrorMonad
open ErrorMonad.Syntax

type eval =
  | Pair of instr list * eval list (** Pairs, used to sotre closure *)
  | Int of int (** Integer *)
  | Epsilon (** Distingueshed symbol used for "frames" *)
  | DummyStack (** Symbol generated by Dummy instruction *)
[@@deriving show { with_path = false }]

let int_of_bool = fun x -> if x then Int 1 else Int 0

let interpret =
  let rec helper acc env arg ret = function
    (* let rec helper acc env arg ret instr = *)
    (*   Format.printf "acc: %a\n" pp_eval acc; *)
    (*   Format.printf "env: "; *)
    (*   List.iter (Format.printf "%a, " pp_eval) env; *)
    (*   Format.printf "\n"; *)
    (*   Format.printf "arg: "; *)
    (*   List.iter (Format.printf "%a, " pp_eval) arg; *)
    (*   Format.printf "\n"; *)
    (*   Format.printf "ret: "; *)
    (*   List.iter (Format.printf "%a, " pp_eval) ret; *)
    (*   Format.printf "\n"; *)
    (*   match instr with *)
    | [] -> return acc
    | Primitive p :: instr ->
      (match p, acc, arg with
       | Add, Int a, Int b :: arg -> helper (Int (a + b)) env arg ret instr
       | Sub, Int a, Int b :: arg -> helper (Int (a - b)) env arg ret instr
       | Mul, Int a, Int b :: arg -> helper (Int (a * b)) env arg ret instr
       | Div, Int a, Int b :: arg -> helper (Int (a / b)) env arg ret instr
       | Less, Int a, Int b :: arg -> helper (int_of_bool (a < b)) env arg ret instr
       | Great, Int a, Int b :: arg -> helper (int_of_bool (a > b)) env arg ret instr
       | LessEq, Int a, Int b :: arg -> helper (int_of_bool (a <= b)) env arg ret instr
       | GreatEq, Int a, Int b :: arg -> helper (int_of_bool (a >= b)) env arg ret instr
       | Equal, Int a, Int b :: arg -> helper (int_of_bool (a = b)) env arg ret instr
       | NeqPhysical, Int a, Int b :: arg | NeqStruct, Int a, Int b :: arg ->
         helper (int_of_bool (a <> b)) env arg ret instr
       | And, Int a, Int b :: arg -> helper (int_of_bool (a = b)) env arg ret instr
       | Or, Int a, Int b :: arg ->
         helper (int_of_bool (a = 1 && b = 1)) env arg ret instr
       | _, _, [] -> fail (`InterpretError "Arg stack is empty in Add")
       | _ -> fail (`InterpretError "Operand is not int"))
    | Const i :: instr -> helper (Int i) env arg ret instr
    (* Accesing local variable *)
    | Access n :: instr ->
      if n < 0
      then fail (`InterpretError "Found negative index")
      else (
        match List.nth_opt env n with
        | Some x -> helper x env arg ret instr
        | None -> fail (`InterpretError "Can't access a variable"))
    (* Applications *)
    | AppTerm :: _ ->
      (match acc, arg with
       | Pair (instr2, env2), v :: arg -> helper acc (v :: env2) arg ret instr2
       | Pair _, _ -> fail (`InterpretError "Argument stack is empty")
       | _ -> fail (`InterpretError "Expected pair in AppTerm"))
    | Apply :: instr ->
      (match acc, arg with
       | Pair (instr2, env2), v :: arg ->
         helper acc (v :: env2) arg (Pair (instr, env) :: ret) instr2
       | Pair _, [] -> fail (`InterpretError "Argument stack is empty in Apply")
       | _, _ -> fail (`InterpretError "Expected pair in Apply"))
    | Push :: instr -> helper acc env (acc :: arg) ret instr
    | PushMark :: instr -> helper acc env (Epsilon :: arg) ret instr
    (* Abstractions *)
    | Cur l :: instr -> helper (Pair (l, env)) env arg ret instr
    | Grab :: instr ->
      (match arg, ret with
       | Epsilon :: arg, Pair (instr2, env2) :: ret ->
         helper (Pair (instr, env)) env2 arg ret instr2
       | v :: arg, ret -> helper acc (v :: env) arg ret instr
       | _, [] -> fail (`InterpretError "Return stack is empty")
       | [], _ :: _ -> fail (`InterpretError "Argument stack is empty"))
    | Return :: _ ->
      (match acc, arg, ret with
       | acc, Epsilon :: arg, Pair (instr2, env2) :: ret -> helper acc env2 arg ret instr2
       | Pair (instr2, env2), v :: arg, ret -> helper acc (v :: env2) arg ret instr2
       | _ -> fail (`InterpretError "Don't know what to do with Return"))
    (* Local declarations *)
    | Let :: instr -> helper acc (acc :: env) arg ret instr
    | EndLet :: instr ->
      (match env with
       | [] -> fail (`InterpretError "Enviroment is empty")
       | _ :: tl -> helper acc tl arg ret instr)
    | Dummy :: instr -> helper acc (DummyStack :: env) arg ret instr
    | Update :: instr ->
      let rec helper_update = function
        | [] -> fail (`InterpretError "Can't find dummy in enviroment")
        | DummyStack :: tl -> return (acc :: tl)
        | h :: tl -> helper_update tl >>= fun tl -> return (h :: tl)
      in
      let* env = helper_update env in
      helper acc env arg ret instr
    (* Branching *)
    | Branch _ :: _ -> failwith "unimpl"
    | BranchIf _ :: _ -> failwith "unimpl"
  in
  helper Epsilon [] [] []
;;

let parse_and_run str =
  let helper str =
    let ( let* ) = Result.bind in
    let* ast = parse str in
    let ast = to_brujin ast in
    let _ = Inferencer.w ast in
    let instr = compile ast in
    run (interpret instr)
  in
  match helper str with
  | Ok v -> Format.printf "Success: %a" pp_eval v
  | Error e -> Format.printf "Error: %a" pp_error e
;;
